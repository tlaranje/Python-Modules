ğŸ”¹ Lambda expressions

    Tornam o cÃ³digo mais conciso porque permitem criar funÃ§Ãµes pequenas em uma
    Ãºnica linha.

    Usa lambda para funÃ§Ãµes simples e descartÃ¡veis; usa def quando a funÃ§Ã£o Ã©
    complexa, reutilizÃ¡vel ou precisa de nome.

ğŸ”¹ Higherâ€‘order functions e funÃ§Ãµes de primeira classe

    Higherâ€‘order functions permitem passar funÃ§Ãµes como argumentos e
    retornÃ¡â€‘las, facilitando reuso e composiÃ§Ã£o.

    FunÃ§Ãµes sÃ£o firstâ€‘class citizens porque podem ser armazenadas em variÃ¡veis,
    passadas, retornadas e colocadas em estruturas de dados como qualquer outro
    valor.

ğŸ”¹ Closures e lexical scoping

    Closures permitem que uma funÃ§Ã£o interna â€œlembreâ€ variÃ¡veis do escopo onde
    foi criada.

    Lexical scoping traz benefÃ­cios como encapsulamento, ausÃªncia de variÃ¡veis
     globais e comportamento previsÃ­vel.

ğŸ”¹ reduce e memoization

    functools.reduce permite agregar uma coleÃ§Ã£o inteira num Ãºnico valor
    aplicando uma funÃ§Ã£o acumuladora.

    lru_cache melhora o desempenho ao guardar resultados jÃ¡ calculados,
    evitando recomputaÃ§Ãµes caras.

ğŸ”¹ Decorators e mÃ©todos estÃ¡ticos

    Decorators separam responsabilidades ao adicionar comportamento extra
    sem modificar a funÃ§Ã£o original.

    @staticmethod nÃ£o recebe self e nÃ£o depende do estado do objeto;
    mÃ©todos normais recebem self e usam dados da instÃ¢ncia.

